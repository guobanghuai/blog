{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{191:function(t,e,n){\"use strict\";n.r(e);var s=n(0),a=Object(s.a)({},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n(\"div\",{staticClass:\"content\"},[n(\"h1\",{attrs:{id:\"insertadjacent-html-text\"}},[t._v(\"insertAdjacent HTML/Text\")]),t._v(\" \"),n(\"h2\",{attrs:{id:\"insertadjacenthtml\"}},[t._v(\"insertAdjacentHTML\")]),t._v(\" \"),t._m(0),t._v(\" \"),t._m(1),t._m(2),t._v(\" \"),t._m(3),t._v(\" \"),n(\"h2\",{attrs:{id:\"insertadjacenttext\"}},[t._v(\"insertAdjacentText\")]),t._v(\" \"),t._m(4),t._v(\" \"),t._m(5),t._v(\" \"),n(\"comment-comment\")],1)},[function(){var t=this.$createElement,e=this._self._c||t;return e(\"p\",[e(\"code\",[this._v(\"insertAdjacentHTML()\")]),this._v(\" 将指定的文本解析为HTML或XML，并将结果节点插入到DOM树中的指定位置。它不会重新解析它正在使用的元素，因此它不会破坏元素内的现有元素。这避免了额外的序列化步骤，使其比直接innerHTML操作更快。\")])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n(\"div\",{staticClass:\"language-javascript extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-javascript\"}},[n(\"code\",[t._v(\"element\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"insertAdjacentHTML\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"position\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" htmlString\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n\")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e(\"p\",[e(\"strong\",[this._v(\"position是相对于元素的位置，并且必须是以下字符串之一 ：\")])])},function(){var t=this.$createElement,e=this._self._c||t;return e(\"ul\",[e(\"li\",[this._v(\"'beforebegin'\\n元素自身的前面。\")]),this._v(\" \"),e(\"li\",[this._v(\"'afterbegin'\\n插入元素内部的第一个子节点之前。\")]),this._v(\" \"),e(\"li\",[this._v(\"'beforeend'\\n插入元素内部的最后一个子节点之后。\")]),this._v(\" \"),e(\"li\",[this._v(\"'afterend'\\n元素自身的后面。\")])])},function(){var t=this.$createElement,e=this._self._c||t;return e(\"p\",[this._v(\"使用方法同上 \"),e(\"code\",[this._v(\"insertAdjacentHTML()\")]),this._v(\"，应在仅插入文本时使用，这样可以不经过HTML解释器的转换，提高性能。\")])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n(\"div\",{staticClass:\"language-javascript extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-javascript\"}},[n(\"code\",[t._v(\"element\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"insertAdjacentText\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"position\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" htmlString\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n\")])])])}],!1,null,null,null);a.options.__file=\"insertAdjacentHTML.md\";e.default=a.exports}}]);","extractedComments":[]}